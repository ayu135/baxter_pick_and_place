#!/usr/bin/env python  
import roslib
import rospy
import math
import tf
import numpy as np
import cv2
import cv_bridge import CvBridge, CvBridge error

#http://wiki.ros.org/tf/Overview/Transformations
#http://wiki.ros.org/tf/Overview/Using%20Published%20Transforms
#to create an offset we can use the following(sec 8.1, 8.2):
from sensor_msgs.msg import Image 
from ar_track_alvar_msgs.msg import AlvarMarker
#from sensor_msgs.msg import JointState 
from geometry_msgs.msg import PoseStamped, Pose, Point, Quaternion, QuaternionStamped,Vector3Stamped
from std_msgs.msg import Header
#from quat import quat_to_so3, so3_to_quat


def xdisplay_pub(data):
    img_pub = rospy.Publisher('/robot/xdisplay', Image, latch=True, queue_size=100)
    #pub = rospy.Publisher('/robot_image', Image, latch=True, queue_size=10)
    img_pub.publish(data)
    

def starting_arm_position():
    #enter something here 
    x =1
    
def circle_find(img_msg):
    bridge = CvBridge()
    try:
        cv_image = bridge.imgmsg_to_cv2(img_msg, "bgr8")
    except CvBridgeError as e:
        print(e)
        
    img = cv2.imread(cv_image,0)
    img = cv2.medianBlur(img,5)
    cimg = cv2.cvtColor(img,cv2.COLOR_GRAY2BGR)
    circles = cv2.HoughCircles(img,cv2.HOUGH_GRADIENT,1,20,
                                param1=50,param2=30,minRadius=5,maxRadius=50)

    circles = np.uint16(np.around(circles))
    for i in circles[0,:]:
        # draw the outer circle
        cv2.circle(cimg,(i[0],i[1]),i[2],(0,255,0),2)
        # draw the center of the circle
        cv2.circle(cimg,(i[0],i[1]),2,(0,0,255),3)

    cv2.imshow('detected circles',cimg)
    
    
    #convert open cv image to ROS image
    im_m = bridge.cv2_to_imgmsg(cv_image, "bgr8")
    pub_img = rospy.Publisher('image_topic',Image)
    pub_img.publish(im_m)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    
def pub_tag_pose(listener, tag_id):
    # you enter here posCB and quatCB which is pose data in quaternions
    #need Rikkis functions to import??
    marker_id = 'ar_marker_%d'%tag_id
    posCB, quatCB = listener.lookupTransform('/cameras/right_hand_camera',marker_id,rospy.Time(0))
    posWC, quatWC = listener.lookupTransform('/base','/cameras/right_hand_camera',rospy.Time(0))

    quatWC = [quatWC[1:4], quatWC[0]]
    quatCB = [quatCB[1:4], quatCB[0]]
    rotWC = quat_to_so3(quatWC)
    rotCB = quat_to_so3(quatCB)
    gWC = RpToTrans(rotWC,posWC)
    gCB = RpToTrans(rotCB,posCB)
    gWB = gWC.dot(gCB)
    rotWB, posWB = TransToRp(gWB)
    quatWB = so3_to_quat(rotWB)


    bpos = Pose()
    bpos.position.x = posWB[0]
    bpos.position.y = posWB[1]
    bpos.position.z = posWB[2]
    bpos.orientation.x = quatWB[1]
    bpos.orientation.y = quatWB[2]
    bpos.orientation.z = quatWB[3]
    bpos.orientation.w = quatWB[0]

    tag_pub = rospy.Publisher('block_position', Pose, queue_size = 10)
    tag_pub.publish(bpos)
    '''
    q = [pos.orientation.w, pos.orientation.x, pos.orientation.y, pos.orientation.z]
    p =[[pos.position.x],[pos.position.y],[pos.position.z]]
        


    tag_pub = rospy.Publisher('block_position', Pose, queue_size = 10)
    pos = Pose()
    pos.position.x = posWB[0]
    pos.position.y = posWB[1]
    pos.position.z = posWB[2]
    pos.orientation.x = rotWB[1]
    pos.orientation.y = rotWB[2]
    pos.orientation.z = rotWB[3]
    pos.orientation.w = rotWB[0]
    '''


def multi_marker(listener,tag_found):
        
    #Creating a list for multiple markers and their locations
    trans = []
    rot = []
    dist = []
    id_list = []

    while tag_found == False:  
        for n in range(1,7):
            marker_id = 'ar_marker_%d'%n
            marker_found = listener.frameExists(marker_id)
            if marker_found == True:
                #print "looking at tag:",n
                (trans_new,rot_new) = listener.lookupTransform('head_camera', marker_id, rospy.Time(0))
                trans.append(trans_new)
                rot.append(rot_new)
                dist.append(np.linalg.norm(trans_new))
                id_list.append(n)
        if len(dist)>0:     
            tag_index = np.argmin(dist)
            print "tag index is", tag_index
            tag_selected = id_list[tag_index]
            tag_transform =  (trans[tag_index],rot[tag_index])
            tag_found = True
            print "Distance is:", dist[np.argmin(dist)]  
        #could add a statement in here to see if block is too close to neighbors
          
    return tag_found, tag_selected
       
    
def main_func():
    #img = Image()
    rospy.init_node('tag_select', anonymous=False)
    rate = rospy.Rate(10) # 10hz
    count = 0
    first_count = True
    listener = tf.TransformListener()
    trans = []
    rot = []
    dist = []
    id_list = []
    tag_found = False
    while not rospy.is_shutdown():
        #This if statement publishes to xdisplay every 2 seconds
        #if count%20 == 0:
            #rospy.Subscriber("/usb_cam/image_raw", Image, xdisplay_pub)
            #rospy.Subscriber("/cameras/right_hand_camera/image", Image, xdisplay_pub)
        #if count%5 == 0
        #    rospy.Subscriber("/cameras/right_hand_camera/image", Image, get_tag_pose)
        '''
        list_frames = listener.getFrameStrings()
        marker_found = listener.frameExists('ar_marker_5')
        if marker_found == True:
            (trans_new,rot_new) = listener.lookupTransform('head_camera', 'ar_marker_5', rospy.Time(0))
            #print trans_new
        
        if marker_found == True and first_count == True:
            first_count = False 
            (trans_old,rot_old) = (trans_new,rot_new)
            trans.append(trans_new)
            rot.append(rot_new)
            print "Marker Found2"
            print trans
        
        if marker_found == True and first_count == False:
            for i in range(len(trans)):
            a = np.round(trans_old[0],2).tolist()
            b = np.round(trans_new[0],2).tolist()
            print "New Marker??"
            
            if a != b:
                print "NEW MARKER FOUND"
                (trans_old,rot_old) = (trans_new, rot_new)
                trans.append(trans_new)
                rot.append(rot_new)
        '''

        '''
        try:
           (trans_new,rot_new) = listener.lookupTransform('head_camera', 'ar_marker_5', rospy.Time(0))
        except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
           marker_found = False
           #print "Marker Found?:", marker_found
        else: 
           #print trans
           x =1
        '''
        #if we want to use multiple markers and pick them up based on distance
        rospy.Subscriber("/usb_cam/image_raw", Image, circle_find)
        tag_found, tag_selected = multi_marker(listener,tag_found)
        #pub_tag_pose(listener,tag_selected)
        count += 1
        print count
        if tag_found == True:
            print "tag selected", tag_selected
            pub_tag_pose(listener,tag_selected)
            rospy.sleep(3)
            break

        rate.sleep()

if __name__ == '__main__':
    
    main_func()
